# Data Analysis for Physicists

* Physics 398DAP, Fall 2023
* Tuesday & Thursday 10:30 - 11:30 am CST
* Room: Loomis 226
* 3 credit hours
* Course Texts: This one!

Welcome! Data is everywhere. Efficient data analysis leading to solid conclusions requires performant tools and rigorous mathematical techniques tethered by sound scientific methods. In this course, you are going to learn and put into practice the fundamentals of probability and data analysis from a physics perspective. The methods of extracting meaningful information from data using probability theory and statistical analyses will be presented. Additionally, students will gain familiarity with the concepts through programming exercises using Python notebooks. Topics to be covered include: basics of statistics and probability theory, probability distributions, estimators, uncertainties, confidence intervals and hypothesis testing, Fourier and Monte Carlo methods.
## Course Logistics
 - **In class sessions for lectures and excercises:** Tuesdays and Thursdays 10:30-11:50pm
 - **Professor:** [Anne Sickles](https://physics.illinois.edu/people/directory/profile/sickles)
    - email: sickles@illinois.edu
    - Office Hours: TBD
 - **Professor:** [Mark Neubauer](https://marksneubauer.com)
    - email: msn@illinois.edu
    - Office Hours: TBD
  - **TA:** TBD
     - email: @illinois.edu
     - Office Hours: TBD

## Online Tools
See [Useful Links](#useful-links) for more information about how to use these awesome tools

* **Campuswire**: We will use [Campuswire](https://campuswire.com) as a class forum, a way to message the course staff and each other, and a means to submit your attendance question.
* **Google Colab**: Using [Google Colab](https://colab.research.google.com), you will be able to program your code in a jupyter notebook and submit it for us to grade. Please sign in to your Illinois account.  While working on the assignment, you will share each of your colab assignments with the professor and the TA (but no one else).
* **Gradescope**: On [Gradescope](https://www.gradescope.com), you will submit your assignments and find your graded assignments.

## Calendar

| Date          | Assignment                                  |
|---------------|---------------------------------------------|
|    August 21	 | Introduction to Statistics and Data Science |
|    August 28  | Probability Theory                          |
| September 04	 | Important Probability Distributions         |
| September 11	 | Theory of Estimators                        |
| September 18	 | Correlation and Covariance                  |
| September 25  | Measurements and Uncertainties              | 
|   October 02  | Frequentist and Bayesian Methods            |
|   October 09	 | Confidence Intervals                        |
|   October 16  | Hypothesis Testing                          |
|   October 23  | Response, Convolution and Unfolding         |
|   October 30  | Fourier Methods                             |
|  November 06	 | Time Series Analysis                        |
|  November 13	 | Monte Carlo Methods                         |
|  November 20  | FALL BREAK - NO CLASSES                     |
|  November 27  | Bias and Blind Analysis                     |
|  December 04  | Machine Learning for Statistical Inference  |

## Coursework

### Computational Assignments
The heart of this course will be a series of computational assignments.
* You will work on the assignments both during class and as homework.
* Each assignment is due at the beginning of the next class unless otherwise noted. You may turn assignment in up to one week late for 50% credit (except that all assignments are strictly due the day before reading day).
* Solutions to the homeworks will not be given.
* The assignments consist of 95% of your grade.
* You may collaborate on assignments but must submit your own work.
* Graded homework will be available through [Gradescope](https://www.gradescope.com)

### Take-Home Final
The take-home final is 5% of your grade will involve demonstrating and extending your work in class by doing something cool and interesting.  You must work alone on this (i.e. without collaboration). The list of possible cool and interesting extensions are in the right-bar under "cool extensions for final."  Many of these are projects that are scheduled for future versions of this course but just aren't written yet (and so are at the difficulty level of the other course projects).  If you have a good idea that you would like to propose, please let the course staff know and we may approve it. The projects are not all equally easy (but there are plenty of easy ones if that is your goal.)  The projects are graded on a very coarse-grained 5 point scale:
* 0 points: didn't submit anything
* 1 point: submitted something but nothing really works
* 4 points: most of the project works but it is not complete 
* 5 points: everything works correctly. 
* 2 and 3 points will interpolate between 1-4 points.  

For the take-home final you will put together a jupyter notebook that demonstrates your extension project. The notebook should have code and demonstrate the task but also be written in an expository way that other students could read and learn from. It is submitted in an analogous way as the regular course assignments.

The final notebook must be submitted via Gradescope for grading on or before ___Friday, December 16, 2022 at 5:00 pm US Central time___.

### Extra Credit
There will be occassional opportunities to get extra credit. To zeroth order these exist because I think they are cool and useful for understanding computational physics but I can't justify within the 2 credit hours of the course.

Extra credit assignments will often be described poorly (maybe even something like, `get a full solar system simulation working'). If you have questions about it, please ask before you spend too much time on it. Also, we have no obligation to make extra credit typo-free. Please try to answer the question we mean to be asking.

For the extra credit, per exercise, the grading is all or nothing. We aren't going to hunt for typos and give partial credit for sortof working code. The amount of extra credit per exercise/etc is listed on the assignment.

## Grading
* Computational Assignments: 95%
* Take-home final: 5%

Your final numerical score is computed as
100 x (0.95 x (Homework Points + Extra Credit Ponts)/(Total Homework Points) + 0.05 x Final

Unless otherwise noted, every exercise in a problem set counts an equal fraction of the assignment and every part (a,b,c,...) of an exercise counts as an equal fraction of the exercise. 5 points of the problem set will be for mandatory questions (e.g. time spent on assignment, references, collaborators).

Sometimes there are typos in the assignment (although we are working hard to remove them). Please ask when confused! Don't spin your wheels a long time on something that might be a typo. These aren't trick questions - we are trying to ask reasonable things.

## Policies

### Covid 

* Policies as it relates to COVID-19 can be found at https://covid19.illinois.edu
* If you feel ill or are unable to come to class or complete class assignments due to issues related to COVID-19, including but not limited to testing positive yourself, feeling ill, caring for a family member with COVID-19, or having unexpected child-care obligations, you should contact your instructor immediately, and you are encouraged to copy your academic advisor. 
  
### About using code you find on the web
The quickest way to deal with the arcana of programing is to ask Google for examples of what you are seeking to accomplish. But you will need to use your judgment in doing this: the Google search “how do I use color maps in python?” is fine, while “show me a script that calculates pi” is not. And you should always credit the original source of code that you paste into your own programs in a comment that includes the URL for the original code. If an author says that his/her code is not to be copied or incorporated into your programs, then DON’T.

I have two principal goals in this course. I want all of you to become fearless coders with the confidence to walk up to baffling problems and pound them into submission. And I want you to develop numerical descriptions of cool systems normally thought to be too difficult for students at your level, whose analytic descriptions might obscure the underlying physics. For this to work, you’ll need to write your own code.

### Academic Integrity
You must never submit the work of someone else as your own. We understand that many of you will find it helpful to work with other students to master Physics 246. But when you collaborate with your study group on homework assignments, you must be a full, active participant in developing the solutions that you submit for credit.

It is cheating to receive answers from another student and then use them as your own. It is cheating to submit as your own work solutions that you find by searching on the worldwide web (though see "About using code you find on the web"), or by subscribing to an online service that suborns cheating. It is cheating—and a violation of U.S. copyright law—to give (or sell) course material to someone else who intends to redistribute and/or sell it.

All activities in this course, are subject to the Academic Integrity rules as described in [Article 1, Part 4, Academic Integrity](https://studentcode.illinois.edu/article1/part4/1-401), of the [Student Code](https://studentcode.illinois.edu).

### Why this course?

As the needs of our students evolve—there is, for example, increasing focus on early readiness for research—the Physics faculty are obliged to adjust both what we teach, and how we teach.

There is a rich tradition of innovation in engineering pedagogy at Illinois. Fifty years ago UIUC became the first school to teach its undergraduates to design computers. More recently, our colleagues have become national leaders in successful efforts to improve instructional outcomes in elementary physics. We intend to continue this Illinois tradition by incorporating computational literacy into the set of core competencies to be mastered by our students.

Just as we require physics majors to enroll in courses taught by Mathematics, but teach the applications of mathematics to physics in our own courses, we hope to do the same with programming. We will continue to require that our students take an introductory course in Computer Science, while incorporating into our own courses machine-based approaches to problems that cannot be solved analytically. Examples include chaos and nonlinear phenomena; fluid dynamics; real-world electrodynamics; quantum mechanics of multi-electron atoms.

This course is a first step. From it, we expect that students will come away with a better grasp of complex phenomena and will be prepared to engage with research experiences that would otherwise have been inaccessible. This will bring to the department's scientific efforts the collateral benefit of an enlarged pool of competent research assistants. If we are successful, our methods should generalize to other disciplines in science and engineering.

**Background:**
The technical foundation for physics majors includes material in physics, mathematics, computer science, and chemistry. But though the courses taught outside the Physics Department provide an excellent introduction to important subjects, they are insufficiently dense in application to specific physics topics to stand on their own. We find this to be especially true in mathematics and computer science. Consequently, the Physics Department offers undergraduate and graduate courses on mathematical methods for physics, as well as a graduate course in computation.

Recently we have now added two new undergraduate courses in computational physics: this course and 498CMP. By simulating physical systems and observing their (simulated) behaviors, students can more efficiently grasp concepts that might be otherwise obscured by mathematical equations. By developing their computational skills, students are better prepared to assist in data acquisition and analysis tasks in a research setting. In addition, about half of our graduating majors choose employment over graduate study; they often report that prospective employers are seeking to hire employees with computational skills.

**246?**
Why 246? Because that's the [vacuum expectation value](https://en.wikipedia.org/wiki/Vacuum_expectation_value) of the [Higgs field](https://en.wikipedia.org/wiki/Higgs_boson). See this [video](https://youtu.be/__btEwKQB2I?t=1) for more about the central role that the Higgs boson plays in the standard model of particle physics and Illinois researchers' role in its discovery!

## Acknowledgements
The current version of this course is a minor evolution by [Mark Neubauer](https://msneubauer.github.io) of the course developed by Bryan Clark.  An earlier version of [this course](https://courses.physics.illinois.edu/phys298owl/fa2018/) was developed and run by [George Gollin](https://physics.illinois.edu/people/directory/profile/g-gollin) and this current version has non-trival overlapping units and problems.  The classifying galaxy assignment closely follows a tutorial at the Galaxy Zoo. The fluid dynamics assignment was originally inspired to get you to develop lattice Boltzmann code similar to that from flowkit.com.  The jupyter-ization of the course was done by Ryan Levy and Bryan Clark.

## Useful Links
Here are some useful links
* [Python Programming Resources](https://wiki.python.org/moin/BeginnersGuide/Programmers)
* [Google's Python Programming Class](https://developers.google.com/edu/python)

## Cool Projects for Final

### Dynamics
* Explore the relationship between Reynolds number and air resistance. The Reynolds number is a dimensionless number that summarizes the fluid flow characteristics and determines the transition from laminar flow to turbulent. Given an object, compute the right value for the terminal velocity and model all sorts of objects and compare their terminal velocity.

### Orbital Dynamics
* Compute a trajectory to launch from the Earth and land on the moon. To accomplish this, you will need to model both the spacecraft and the moon orbiting around the Earth. In addition you will need to take into account the fact that the Earth is rotating and so gives an initial velocity to the spacecraft.
* Compute a trajectory to launch from the Earth to Mars.
* Model the trajectory of voyager through the Solar System. This requires some intermediate thrusts from voyager and requires modeling a large part of the solar system. This is a somewhat challenging project. If you want to do this, you are essentially allowed to look anything up (i.e. you can go look up any information about voyager).
* Lagrange points via optimization: Find the lagrange points between the Sun and Earth by combining your orbital dynamics simulation and scipy.optimize. Once you’ve found them, show that they work by modeling them in your simulations nad then show that two of them are stable and three of them are unstable.
* Modeling the orbit of a spacecraft around a black hole: We modeled the perihelion at Mercury by taking the effect of general relativity to first order. If you want to model orbiting around a black hole you need to actually use the proper GR equations of motion. See Black Holes book.
* Simulate the famous twin paradox from special relativity
* Nice model for planetary formation

### Exoplanets
* Do the exoplanet assignment but get the data from a many-body simulation with two planets + the sun. Write code that gets the oscillations for the largest planet. Also write code that correctly accounts for the fact that the solar system you are emulating isn’t aligned with the Earth.

### Chaos
* Do a full simulation of the solar system. You probably want to implement a symplectic integrator to do this.
* Do a galaxy simulation. You probably want to implement a symplectic integrator to do this. You may want to implement a method to speed up the use of the gravitiational force. You can use jax for this project which probably wil make your life simpler.
* With a few lines of code, I think you should be able to turn your jax result into a code that simulates a gas inside a room. Compute something interesting for this gas.
* https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.84.1240 PRL “freezing by heating model”
* https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6308419/#B1-sensors-18-04149
* Itaewon crowd crush: https://www.engineering.com/story/could-crowd-simulation-software-have-prevented-the-seoul-disaster

### Random Walks / Markov Chains
* Implement a path integral Monte Carlo code for a particle in a box; an extension of this is to implement a path integral Monte Carlo code for a Harmonic oscillator
* Implement an Ising model.

### Predator-Prey
* Epidemic Modeling
* Agent Based Approach: Play “Survivor: Bunny Edition”. The purpose of reinforcement learning (RL) is for the agent to learn an optimal, or nearly-optimal, policy that maximizes a "reward function”. In our case, this is longevity of a given bunny. Implement an RL engine (e.g. via Q-learning) that learns and optimal policy for bunny survival assuming that a bunny can see the contents of its “local” environment (i.e. # bunnies and # foxes in neighboring squares). 
* Mathematical models such as the Susceptible, Infectious, and/or Recovered (SIR) model are used to predict different scenarios related to epidemiologic factors and possible outcomes to assess epidemic spread. Implement an SIR Model
* On the agent evolution, start with 100 foxes and keep track of who is a given fox descendent. Visualize this in your animation by color…separately plot the number of descendants of each original fox as a function of time
* Add evolution to your simulation … allow foxes and bunnies to adjust speed , when they starve and fraction to reproduce. You’ll need to add these to the class
* There is an interesting fact I’ve hear about humans that you don’t have to go too many generations back before you are a descendant of everyone or no one. Model this in an agent-based model.
* Add various interactions (e.g. could be bunny-bunny attraction term, or bunny-fox repulsion, or any more complex interactions like spin-spin interactions assuming intrinsic spin or attraction/repulsion based on a new intrinsic property - get creative!)  to your bunnies and foxes and study simulation outcomes/metric. 
* Hp model of protein folding
* Implement some version of blast

### Fluid Dynamics
* GPU version of lattice Boltzmann
* Machine learning on lattice Boltzmann fluid dynamics
* Model moving objects in your fluid dynamics simulation and measure the air resistance to different types of shapes
* Take your fluid dynamics data and look at different quantities. Measure the curl and density and visualize these side by side

### Machine Learning Galaxies
* Break 80% using the full dataset. You can look up whatever you want to pull this off as well as use pytorch, stax, etc.
* Implement a Convolutional Neural Network using Keras/Tensorflow or PyTorch for galaxy classification. Compare the accuracy with different hyperparameters and with your simple, hand-coded MLP that you did for the original assignment. 
* Implement a Fully-connected Deep Neural Network using Keras/Tensorflow or PyTorch for galaxy classification. Compare the accuracy with different hyperparameters (e.g. # hidden layers) and with your simple, hand-coded MLP that you did for the original assignment. 

### Quantum Computing
* Shadow tomography
* (Delayed Choice) Quantum Eraser

### Climate Modeling
* Approach 1: Energy Balance Model
* Approach 2: AquaLand
* E&M: Implement code that solve poisson’s equation for a bunch of wires and point charges.
* Heat Equation: Implement something that takes a bar with heat on the two edges and models how it distributes
* Simulated Annealing: Implement and do some simulated annealing.
* Implement the schrodinger equation
* Do diagramatic Monte Carlo
